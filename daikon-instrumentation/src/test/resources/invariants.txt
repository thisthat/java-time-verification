===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:::CLASS
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log has only one value
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log != null
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == org.slf4j.impl.SimpleLogger.class
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:::OBJECT
this.assignors != null
this.assignors[] elements != null
this.metadata != null
this.sensors != null
this.subscriptions != null
this.defaultOffsetCommitCallback != null
this.autoCommitIntervalMs >= 0
this.pendingAsyncCommits != null
this.completedOffsetCommits != null
this.metadataSnapshot != null
this.nextAutoCommitDeadline >= 0
size(this.assignors[]) one of { 1, 2 }
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.ConsumerCoordinator(org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient, java.lang.String, int, int, int, java.util.List, org.apache.kafka.clients.Metadata, org.apache.kafka.clients.consumer.internals.SubscriptionState, org.apache.kafka.common.metrics.Metrics, java.lang.String, org.apache.kafka.common.utils.Time, long, org.apache.kafka.clients.consumer.OffsetCommitCallback, boolean, int, org.apache.kafka.clients.consumer.internals.ConsumerInterceptors, boolean):::ENTER
client != null
groupId != null
rebalanceTimeoutMs one of { 6000, 60000, 300000 }
sessionTimeoutMs one of { 3000, 10000, 30000 }
assignors != null
assignors[] elements != null
metadata != null
subscriptions != null
metrics != null
metricGrpPrefix != null
metricGrpPrefix.toString one of { "consumer", "consumertest-group", "consumertestCloseTimeoutWithHeartbeatThread" }
time != null
retryBackoffMs == 100
defaultOffsetCommitCallback != null
size(assignors[]) one of { 1, 2 }
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.ConsumerCoordinator(org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient, java.lang.String, int, int, int, java.util.List, org.apache.kafka.clients.Metadata, org.apache.kafka.clients.consumer.internals.SubscriptionState, org.apache.kafka.common.metrics.Metrics, java.lang.String, org.apache.kafka.common.utils.Time, long, org.apache.kafka.clients.consumer.OffsetCommitCallback, boolean, int, org.apache.kafka.clients.consumer.internals.ConsumerInterceptors, boolean):::EXIT
assignors[] == orig(assignors[])
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
assignors[] elements != null
metricGrpPrefix.toString one of { "consumer", "consumertest-group", "consumertestCloseTimeoutWithHeartbeatThread" }
groupId.toString == orig(groupId.toString)
metricGrpPrefix.toString == orig(metricGrpPrefix.toString)
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.addMetadataListener():::ENTER
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.addMetadataListener():::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.close(long):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000, 5000 }
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
timeoutMs >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.close(long):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000, 5000 }
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.commitOffsetsAsync(java.util.Map, org.apache.kafka.clients.consumer.OffsetCommitCallback):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
offsets != null
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.commitOffsetsAsync(java.util.Map, org.apache.kafka.clients.consumer.OffsetCommitCallback):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.commitOffsetsSync(java.util.Map, long):::ENTER
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
offsets != null
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.commitOffsetsSync(java.util.Map, long):::EXIT505
this.metadataSnapshot == orig(this.metadataSnapshot)
this.autoCommitEnabled == true
this.joinedSubscription.getClass().getName() == java.util.HashSet.class
orig(offsets.getClass().getName()) == java.util.HashMap.class
orig(timeoutMs) one of { 30000, 60000 }
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.commitOffsetsSync(java.util.Map, long):::EXIT519
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor] }
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
orig(timeoutMs) one of { 1000, 60000, 9223372036854775807L }
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.commitOffsetsSync(java.util.Map, long):::EXIT530
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == true
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
orig(offsets.getClass().getName()) == java.util.HashMap.class
orig(timeoutMs) one of { 1000, 60000 }
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.commitOffsetsSync(java.util.Map, long):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.doAutoCommitOffsetsAsync():::ENTER
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.doAutoCommitOffsetsAsync():::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.doCommitOffsetsAsync(java.util.Map, org.apache.kafka.clients.consumer.OffsetCommitCallback):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
offsets != null
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.doCommitOffsetsAsync(java.util.Map, org.apache.kafka.clients.consumer.OffsetCommitCallback):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.fetchCommittedOffsets(java.util.Set):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
partitions.getClass().getName() == java.util.HashSet.class
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.fetchCommittedOffsets(java.util.Set):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
return.getClass().getName() == java.util.HashMap.class
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_140_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
arg1 >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_140_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_149_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription != null
arg1 >= 0
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_149_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription != null
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_152_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription != null
arg1 >= 0
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_152_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription != null
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_188_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
arg1 >= 0
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_188_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_251_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::ENTER
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.assignors.getClass().getName() == java.util.Arrays$ArrayList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitIntervalMs one of { 0, 1000, 10000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
arg0 one of { 0, 1000, 10000 }
arg2 >= 0
arg3 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_251_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.assignors.getClass().getName() == java.util.Arrays$ArrayList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitIntervalMs one of { 0, 1000, 10000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_259_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg2 >= 0
arg3 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_259_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_262_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg2 >= 0
arg3 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_262_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_267_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
arg3 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_267_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_276_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::ENTER
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.assignors.getClass().getName() == java.util.Arrays$ArrayList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitIntervalMs one of { 0, 1000, 10000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.HashSet.class
this.assignmentSnapshot == null
arg0 one of { 0, 1000, 10000 }
arg3 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_276_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.assignors.getClass().getName() == java.util.Arrays$ArrayList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitIntervalMs one of { 0, 1000, 10000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.HashSet.class
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_279_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::ENTER
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.assignors.getClass().getName() == java.util.Arrays$ArrayList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 10000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.HashSet.class
this.assignmentSnapshot == null
arg0 one of { 1000, 10000 }
arg3 == true
arg4 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_279_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.assignors.getClass().getName() == java.util.Arrays$ArrayList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 10000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.HashSet.class
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_282_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::ENTER
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.assignors.getClass().getName() == java.util.Arrays$ArrayList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 10000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.HashSet.class
this.assignmentSnapshot == null
arg0 one of { 1000, 10000 }
arg3 == true
arg4 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_282_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.assignors.getClass().getName() == java.util.Arrays$ArrayList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 10000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.HashSet.class
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_290_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.nextAutoCommitDeadline one of { 0, 1518431135483L, 1518431135739L }
arg0 == 2000
arg1 one of { 0, 1518431135483L, 1518431135739L }
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_290_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.nextAutoCommitDeadline one of { 0, 1518431135483L, 1518431135739L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_297_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.nextAutoCommitDeadline one of { 0, 1518431135483L, 1518431135739L }
arg0 == 2000
arg1 one of { 0, 1518431135483L, 1518431135739L }
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_297_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.nextAutoCommitDeadline one of { 0, 1518431135483L, 1518431135739L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_322_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == true
this.nextAutoCommitDeadline one of { 0, 1518431135483L, 1518431135739L }
arg0 == 2000
arg1 one of { 0, 1518431135483L, 1518431135739L }
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_322_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == true
this.nextAutoCommitDeadline one of { 0, 1518431135483L, 1518431135739L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_326_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == true
this.nextAutoCommitDeadline one of { 0, 1518431135483L, 1518431135739L }
arg0 == 2000
arg1 one of { 0, 1518431135483L, 1518431135739L }
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_326_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == true
this.nextAutoCommitDeadline one of { 0, 1518431135483L, 1518431135739L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_353_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
arg0 >= 0
arg1 >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_353_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_357_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
arg0 >= 0
arg1 >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_357_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_361_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
arg0 >= 0
arg1 >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_361_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_364_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
arg0 >= 0
arg1 >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_364_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_376_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
arg0 one of { 1000, 2000 }
arg1 one of { 0, 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_376_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_378_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
arg0 one of { 1000, 2000 }
arg1 one of { 0, 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_378_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_380_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
arg0 one of { 1000, 2000 }
arg1 one of { 0, 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_380_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_396_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
arg0 one of { 1000, 2000 }
arg1 one of { 0, 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_396_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_399_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline == 0
arg0 == 2000
arg1 == 0
arg2 == false
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_399_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline == 0
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_401_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline == 0
arg0 == 2000
arg1 == 0
arg2 == false
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_401_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline == 0
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_403_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline == 0
arg0 == 2000
arg1 == 0
arg2 == false
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_403_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline == 0
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_419_timeoutMs_endTimeMs_autoCommitIntervalMs_now_nextAutoCommitDeadline(long, long, int, long, long, boolean, boolean, boolean, boolean):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000, 5000 }
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg0 >= 0
arg2 one of { 1000, 2000, 5000 }
arg5 == true
arg6 == false
arg7 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_419_timeoutMs_endTimeMs_autoCommitIntervalMs_now_nextAutoCommitDeadline(long, long, int, long, long, boolean, boolean, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000, 5000 }
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_421_timeoutMs_endTimeMs_autoCommitIntervalMs_now_nextAutoCommitDeadline(long, long, int, long, long, boolean, boolean, boolean, boolean):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000, 5000 }
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg0 >= 0
arg2 one of { 1000, 2000, 5000 }
arg5 == true
arg6 == false
arg7 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_421_timeoutMs_endTimeMs_autoCommitIntervalMs_now_nextAutoCommitDeadline(long, long, int, long, long, boolean, boolean, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000, 5000 }
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_428_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg1 >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_428_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_429_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg1 >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_429_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_431_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor] }
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431133000L }
this.nextAutoCommitDeadline == 0  (mod 2)
arg0 one of { 1000, 2000 }
arg1 one of { 0, 1518431128274L, 1518431133000L }
arg1 == 0  (mod 2)
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_431_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor] }
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431133000L }
this.nextAutoCommitDeadline == 0  (mod 2)
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_438_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg0 one of { 1000, 2000 }
arg1 >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_438_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_459_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg0 one of { 1000, 2000 }
arg1 >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_459_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_466_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg0 one of { 1000, 2000 }
arg1 >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_466_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_491_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg0 one of { 1000, 2000 }
arg1 >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_491_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_505_timeoutMs_autoCommitIntervalMs_nextAutoCommitDeadline(long, int, long, boolean, boolean):::ENTER
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg2 >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_505_timeoutMs_autoCommitIntervalMs_nextAutoCommitDeadline(long, int, long, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_518_timeoutMs_startMs_remainingMs_autoCommitIntervalMs_now_nextAutoCommitDeadline(long, long, long, int, long, long, boolean, boolean, boolean, boolean, boolean):::ENTER
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor] }
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg0 one of { 1000, 60000, 9223372036854775807L }
arg2 one of { 1000, 60000, 9223372036854775707L }
arg3 one of { 1000, 2000 }
arg5 >= 0
arg9 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_518_timeoutMs_startMs_remainingMs_autoCommitIntervalMs_now_nextAutoCommitDeadline(long, long, long, int, long, long, boolean, boolean, boolean, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor] }
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_523_timeoutMs_startMs_remainingMs_autoCommitIntervalMs_now_nextAutoCommitDeadline(long, long, long, int, long, long, boolean, boolean, boolean, boolean, boolean):::ENTER
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
this.assignmentSnapshot == null
arg2 >= -1
arg3 == 2000
arg5 >= 0
arg9 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_523_timeoutMs_startMs_remainingMs_autoCommitIntervalMs_now_nextAutoCommitDeadline(long, long, long, int, long, long, boolean, boolean, boolean, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_528_timeoutMs_startMs_remainingMs_autoCommitIntervalMs_now_nextAutoCommitDeadline(long, long, long, int, long, long, boolean, boolean, boolean, boolean, boolean):::ENTER
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
this.assignmentSnapshot == null
arg0 one of { 1000, 60000, 9223372036854775807L }
arg2 one of { -1, 9223372036854775807L }
arg3 == 2000
arg5 >= 0
arg9 == true
arg10 == false
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_528_timeoutMs_startMs_remainingMs_autoCommitIntervalMs_now_nextAutoCommitDeadline(long, long, long, int, long, long, boolean, boolean, boolean, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_530_timeoutMs_startMs_remainingMs_autoCommitIntervalMs_now_nextAutoCommitDeadline(long, long, long, int, long, long, boolean, boolean, boolean, boolean, boolean):::ENTER
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
this.assignmentSnapshot == null
arg0 one of { 1000, 60000, 9223372036854775807L }
arg2 one of { -101, 9223372036854775707L }
arg3 == 2000
arg5 >= 0
arg9 == true
arg10 == false
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_530_timeoutMs_startMs_remainingMs_autoCommitIntervalMs_now_nextAutoCommitDeadline(long, long, long, int, long, long, boolean, boolean, boolean, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_535_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::ENTER
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 2000, 10000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg0 one of { 1000, 2000, 10000 }
arg3 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_535_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 2000, 10000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_538_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::ENTER
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RoundRobinAssignor], [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor] }
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg0 one of { 1000, 2000 }
arg3 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_538_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RoundRobinAssignor], [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor] }
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_539_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::ENTER
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RoundRobinAssignor], [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor] }
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg0 one of { 1000, 2000 }
arg3 == true
arg4 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_539_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RoundRobinAssignor], [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor] }
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_541_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
arg3 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_541_autoCommitIntervalMs_now_nextAutoCommitDeadline(int, long, long, boolean, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_545_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitIntervalMs one of { 1000, 5000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
arg0 one of { 1000, 5000 }
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_545_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitIntervalMs one of { 1000, 5000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_546_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.assignors.getClass().getName() == java.util.Arrays$ArrayList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitEnabled == true
this.autoCommitIntervalMs == 1000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 1518431128274L, 1518431128341L }
arg0 == 1000
arg1 one of { 1518431128274L, 1518431128341L }
arg2 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_546_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.assignors.getClass().getName() == java.util.Arrays$ArrayList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitEnabled == true
this.autoCommitIntervalMs == 1000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_561_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg0 one of { 1000, 2000 }
arg2 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_561_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_566_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.autoCommitEnabled == true
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
arg2 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_566_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitEnabled == true
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_572_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == true
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 1518431133006L, 1518431134240L, 1518431135614L }
arg0 == 2000
arg1 one of { 1518431133006L, 1518431134240L, 1518431135614L }
arg2 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_572_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == true
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 1518431133006L, 1518431134240L, 1518431135614L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_573_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == true
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 1518431133006L, 1518431134240L, 1518431135614L }
arg0 == 2000
arg1 one of { 1518431133006L, 1518431134240L, 1518431135614L }
arg2 == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_573_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == true
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 1518431133006L, 1518431134240L, 1518431135614L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_575_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.excludeInternalTopics == true
arg1 >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_575_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.excludeInternalTopics == true
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_721_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
arg0 one of { 1000, 2000 }
arg1 one of { 0, 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invariant_721_autoCommitIntervalMs_nextAutoCommitDeadline(int, long, boolean):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invokeCompletedOffsetCommitCallbacks():::ENTER
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invokeCompletedOffsetCommitCallbacks():::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.lookupAssignor(java.lang.String):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
this.joinedSubscription != null
name != null
name.toString one of { "consumer-mock-assignor", "range", "roundrobin" }
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.lookupAssignor(java.lang.String):::EXIT193
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.lookupAssignor(java.lang.String):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
this.joinedSubscription != null
name.toString one of { "consumer-mock-assignor", "range", "roundrobin" }
return != null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
name.toString == orig(name.toString)
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.maybeAutoCommitOffsetsAsync(long):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.maybeAutoCommitOffsetsAsync(long):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.interceptors == null
this.excludeInternalTopics == true
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.maybeAutoCommitOffsetsNow():::ENTER
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitIntervalMs one of { 1000, 5000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.maybeAutoCommitOffsetsNow():::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitIntervalMs one of { 1000, 5000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.maybeAutoCommitOffsetsSync(long):::ENTER
this.excludeInternalTopics == true
timeoutMs >= 0
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.maybeAutoCommitOffsetsSync(long):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.excludeInternalTopics == true
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.metadata():::ENTER
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.metadata():::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription != null
return != null
return[] elements != null
return[].getClass().getName() elements == org.apache.kafka.common.requests.JoinGroupRequest.ProtocolMetadata.class
return[].getClass().getName() one of { [org.apache.kafka.common.requests.JoinGroupRequest.ProtocolMetadata], [org.apache.kafka.common.requests.JoinGroupRequest.ProtocolMetadata, org.apache.kafka.common.requests.JoinGroupRequest.ProtocolMetadata] }
return.getClass().getName() == java.util.ArrayList.class
size(return[]) one of { 1, 2 }
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.needRejoin():::ENTER
this.interceptors == null
this.excludeInternalTopics == true
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.needRejoin():::EXIT353
this.autoCommitIntervalMs one of { 1000, 2000 }
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
return == false
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.needRejoin():::EXIT353;condition="not(return == true)"
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.needRejoin():::EXIT357
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.isLeader == true
this.nextAutoCommitDeadline one of { 1518431134855L, 1518431135483L, 1518431135739L }
return == true
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.needRejoin():::EXIT357;condition="return == true"
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.needRejoin():::EXIT361
this.autoCommitIntervalMs one of { 1000, 2000 }
this.isLeader == false
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 1518431128284L, 1518431128312L, 1518431137868L }
return == true
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.needRejoin():::EXIT361;condition="return == true"
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.needRejoin():::EXIT363
(return == false)  ==>  (this.joinedSubscription != null)
(return == true)  ==>  (this.assignmentSnapshot == null)
(return == true)  ==>  (this.isLeader == false)
(return == true)  ==>  (this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class)
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.needRejoin():::EXIT363;condition="return == true"
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
this.assignmentSnapshot == null
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.needRejoin():::EXIT363;condition="not(return == true)"
this.joinedSubscription != null
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.needRejoin():::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.needRejoin():::EXIT;condition="return == true"
return == true
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.needRejoin():::EXIT;condition="not(return == true)"
return == false
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.onJoinComplete(int, java.lang.String, java.lang.String, java.nio.ByteBuffer):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
this.joinedSubscription != null
generation one of { 1, 2 }
memberId != null
memberId.toString one of { "consumer", "leader", "memberId" }
assignmentStrategy != null
assignmentStrategy.toString one of { "consumer-mock-assignor", "range", "roundrobin" }
assignmentBuffer != null
assignmentBuffer.getClass().getName() == java.nio.HeapByteBuffer.class
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.onJoinComplete(int, java.lang.String, java.lang.String, java.nio.ByteBuffer):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.interceptors == null
this.excludeInternalTopics == true
this.joinedSubscription != null
memberId.toString one of { "consumer", "leader", "memberId" }
assignmentStrategy.toString one of { "consumer-mock-assignor", "range", "roundrobin" }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
this.nextAutoCommitDeadline >= orig(this.nextAutoCommitDeadline)
memberId.toString == orig(memberId.toString)
assignmentStrategy.toString == orig(assignmentStrategy.toString)
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.onJoinPrepare(int, java.lang.String):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
generation one of { -1, 1 }
generation != 0
generation == 1  (mod 2)
memberId != null
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.onJoinPrepare(int, java.lang.String):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.joinedSubscription == orig(this.joinedSubscription)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
memberId.toString == orig(memberId.toString)
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.performAssignment(java.lang.String, java.lang.String, java.util.Map):::ENTER
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.nextAutoCommitDeadline one of { 0, 1518431135483L, 1518431135739L }
leaderId.toString one of { "consumer", "leader" }
assignmentStrategy has only one value
assignmentStrategy.toString == "consumer-mock-assignor"
allSubscriptions.getClass().getName() == java.util.HashMap.class
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.performAssignment(java.lang.String, java.lang.String, java.util.Map):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == true
this.nextAutoCommitDeadline one of { 0, 1518431135483L, 1518431135739L }
leaderId.toString one of { "consumer", "leader" }
assignmentStrategy.toString == "consumer-mock-assignor"
return.getClass().getName() == java.util.HashMap.class
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
leaderId.toString == orig(leaderId.toString)
assignmentStrategy.toString == orig(assignmentStrategy.toString)
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.poll(long):::ENTER
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.poll(long):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.interceptors == null
this.excludeInternalTopics == true
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.protocolType():::ENTER
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.protocolType():::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
return has only one value
return != null
return.toString == "consumer"
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.refreshCommittedOffsetsIfNeeded():::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.refreshCommittedOffsetsIfNeeded():::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.sendOffsetCommitRequest(java.util.Map):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
offsets != null
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.sendOffsetCommitRequest(java.util.Map):::EXIT595
this.assignors has only one value
this.assignors[] contains no nulls and has only one value, of length 1
this.assignors[] elements has only one value
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.RoundRobinAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.RoundRobinAssignor.class
this.assignors.getClass().getName() == java.util.Arrays$ArrayList.class
this.metadata has only one value
this.sensors has only one value
this.subscriptions has only one value
this.defaultOffsetCommitCallback has only one value
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitEnabled == true
this.autoCommitIntervalMs == 1000
this.pendingAsyncCommits has only one value
this.completedOffsetCommits has only one value
this.joinedSubscription == null
this.metadataSnapshot has only one value
this.nextAutoCommitDeadline == 1518431128341L
return has only one value
orig(this) has only one value
orig(offsets) has only one value
orig(offsets.getClass().getName()) == java.util.HashMap.class
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.sendOffsetCommitRequest(java.util.Map):::EXIT599
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == true
this.autoCommitIntervalMs == 2000
this.joinedSubscription.getClass().getName() == java.util.Collections$SingletonSet.class
orig(offsets.getClass().getName()) == java.util.HashMap.class
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.sendOffsetCommitRequest(java.util.Map):::EXIT606
this.assignors[].getClass().getName() == [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor]
this.assignors[].getClass().getName() elements == org.apache.kafka.clients.consumer.internals.MockPartitionAssignor.class
this.assignors.getClass().getName() == java.util.Collections$SingletonList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinatorTest$MockCommitCallback.class
this.autoCommitEnabled == false
this.autoCommitIntervalMs == 2000
this.joinedSubscription == null
this.nextAutoCommitDeadline == 0
orig(offsets.getClass().getName()) == java.util.Collections$SingletonMap.class
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.sendOffsetCommitRequest(java.util.Map):::EXIT632
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.sendOffsetCommitRequest(java.util.Map):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.assignmentSnapshot == null
return != null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.sendOffsetFetchRequest(java.util.Set):::ENTER
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
partitions.getClass().getName() == java.util.HashSet.class
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.sendOffsetFetchRequest(java.util.Set):::EXIT730
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.sendOffsetFetchRequest(java.util.Set):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription == null
this.assignmentSnapshot == null
this.nextAutoCommitDeadline one of { 0, 1518431128274L, 1518431128341L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.timeToNextPoll(long):::ENTER
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.assignors.getClass().getName() == java.util.Arrays$ArrayList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitIntervalMs one of { 0, 1000, 10000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.HashSet.class
this.assignmentSnapshot == null
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.timeToNextPoll(long):::EXIT276
this.autoCommitEnabled == false
this.autoCommitIntervalMs one of { 0, 1000 }
return one of { 3000, 5000, 9223372036854775807L }
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.timeToNextPoll(long):::EXIT281
this.autoCommitEnabled == true
this.autoCommitIntervalMs one of { 1000, 10000 }
return one of { 100, 1000 }
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.timeToNextPoll(long):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RangeAssignor], [org.apache.kafka.clients.consumer.RoundRobinAssignor] }
this.assignors.getClass().getName() == java.util.Arrays$ArrayList.class
this.defaultOffsetCommitCallback.getClass().getName() == org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$DefaultOffsetCommitCallback.class
this.autoCommitIntervalMs one of { 0, 1000, 10000 }
this.interceptors == null
this.excludeInternalTopics == true
this.isLeader == false
this.joinedSubscription.getClass().getName() == java.util.HashSet.class
this.assignmentSnapshot == null
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.updatePatternSubscription(org.apache.kafka.common.Cluster):::ENTER
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RoundRobinAssignor], [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor] }
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.joinedSubscription.getClass().getName() == java.util.HashSet.class
this.nextAutoCommitDeadline one of { 0, 1518431128053L, 1518431128312L }
size(this.assignors[]) == 1
===========================================================================
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.updatePatternSubscription(org.apache.kafka.common.Cluster):::EXIT
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log)
this.assignors == orig(this.assignors)
this.assignors[] == orig(this.assignors[])
this.metadata == orig(this.metadata)
this.sensors == orig(this.sensors)
this.subscriptions == orig(this.subscriptions)
this.defaultOffsetCommitCallback == orig(this.defaultOffsetCommitCallback)
this.autoCommitEnabled == orig(this.autoCommitEnabled)
this.autoCommitIntervalMs == orig(this.autoCommitIntervalMs)
this.interceptors == orig(this.interceptors)
this.excludeInternalTopics == orig(this.excludeInternalTopics)
this.pendingAsyncCommits == orig(this.pendingAsyncCommits)
this.completedOffsetCommits == orig(this.completedOffsetCommits)
this.isLeader == orig(this.isLeader)
this.joinedSubscription == orig(this.joinedSubscription)
this.metadataSnapshot == orig(this.metadataSnapshot)
this.assignmentSnapshot == orig(this.assignmentSnapshot)
this.nextAutoCommitDeadline == orig(this.nextAutoCommitDeadline)
this.assignors[].getClass().getName() one of { [org.apache.kafka.clients.consumer.RoundRobinAssignor], [org.apache.kafka.clients.consumer.internals.MockPartitionAssignor] }
this.autoCommitIntervalMs one of { 1000, 2000 }
this.interceptors == null
this.joinedSubscription.getClass().getName() == java.util.HashSet.class
this.nextAutoCommitDeadline one of { 0, 1518431128053L, 1518431128312L }
size(this.assignors[]) == 1
org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName() == orig(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.log.getClass().getName())
this.assignors.getClass().getName() == orig(this.assignors.getClass().getName())
this.defaultOffsetCommitCallback.getClass().getName() == orig(this.defaultOffsetCommitCallback.getClass().getName())
this.joinedSubscription.getClass().getName() == orig(this.joinedSubscription.getClass().getName())
